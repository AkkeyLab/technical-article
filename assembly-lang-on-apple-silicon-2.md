# Apple Silicon のためのアセンブリ入門【続編】

## Introduction
iOSDC Japan 2023 のパンフレット記事として掲載された「Apple Silicon のためのアセンブリ入門」の続編です。前回はニーモニックと文字出力について解説しましたが、本稿では演算処理をアセンブリで記述する方法に焦点を当てます。

Intel CPU を搭載した Apple デバイスがストアから姿を消すなど、 Apple Silicon は大きく進化しました。
私たちがこの Apple Silicon と非常に近い距離で対話する手段、それがアセンブリです。
アセンブリは機械語に非常に近い低水準言語であり、特定の CPU アーキテクチャに依存して記述方法が異なります。これに対して、Swift などの高水準言語では記述方法がほとんど変わらないため、アセンブリの特性について疑問を抱く方もいるかもしれません。

本稿では、 Apple Silicon 上でアセンブリを用いて演算処理を行う方法を紹介します。最初は仕事に直接役立たないように思えるかもしれませんが、日常的に Swift で書いている演算処理がコンパイラによってどのように機械語に変換されているのかを理解する絶好の機会です。きっと Apple Silicon がさらに魅力的に感じられるでしょう！

## 前提
本稿では基礎知識の無い方にも読んでいただけるように心がけて執筆いたしました。そのため、例外を省略して説明している箇所があります。  
たとえば「Apple Silicon のため」と言っても、ARMアーキテクチャを採用した CPU に共通するもので、他社製品にも通用する事柄だったりします。

また、去年の記事をご覧になっていない方でも楽しんでいただける構成にする関係で、iOSDC Japan 2023 のパンフレット記事と重複する箇所があることをご理解いただけますと幸いです。

## アセンブリとは
アセンブリ（Assembly）は日本語で「組み立て」を意味する単語で、本稿ではアセンブリ言語のことを指します。アセンブリはプログラミング言語のひとつで、機械語と 1:1 に対応した言語のことを言います。表現のひとつとして、アセンブラ言語とも呼ばれますが、本稿ではアセンブリ言語と表現し、アセンブリで書かれたプログラムを機械語に変換するツールをアセンブラ（Assembler）と呼ぶことにします。さらに、機械語に変換すことをアセンブル（Assemble）と呼ぶので、アセンブリをアセンブラでアセンブルすると説明することができます。

ところで、皆さんはアセンブリでプログラミングされている製品が現代でも活躍していることをご存知ですか？それは遊技機と呼ばれるもので、特にメイン基板のROMやRAMの容量が非常に小さいことがアセンブリの採用理由となっています。

## 四則演算と表示
本稿では、アセンブリを使用して四則演算結果を表示するプログラムを作成し、実行するまでの手順を説明します。アセンブリを使用することで、コンピュータの低レベルな動作やシステムコールの利用方法を理解することができます。

1. 四則演算
2. 演算結果をASCIIコードに変換
3. システムコールの把握
4. システムコールの実行
5. プログラムの正常終了
6. センブリをアセンブラでアセンブルする
7. バイナリファイルの作成と実行

上記の手順を実践するだけで、アセンブリでのコーディングからプログラムの実行までを行うことができます。  
ここで、システムコールという用語が多く登場していることに気づくかと思います。実は、機械語に近いアセンブリであっても、CPU を自由自在に操作できるわけではなく、カーネルに対してシステムコールという命令を行うことで処理を実行することになります。たとえば、標準出力を行う場合には、システムコールを使用してカーネルに出力を依頼します。これは Swift で `print` 関数を用いて標準出力を行う感覚に近いかもしれません。

### 1. 四則演算
今回は2つの整数と、それらを四則演算処理した結果という3つの値を取り扱うこととします。アセンブリでは、これらの3つをそれぞれレジスタに格納することから考えます。次に5と4を加算するコード例を示します。

```s
// オペコード
// ↓
  mov X0, #5     // レジスタ X0 に値 5 を設定
  mov X1, #4     // レジスタ X1 に値 4 を設定
  add X2, X0, X1 // レジスタ X2 に X0 + X1 の結果を設定
//    ~~~~~~~~~~
//        ↑
//     オペランド
```

オペコードと呼ばれる命令には `mov` というローマ字が利用されています。これは、move という英単語が語源で、値の移動を行う命令です。ここで、機械語に近い言語のわりには分かりやすい表現になっていることに気づくかと思います。これはニーモニック（Mnemonic）という表現で、CPU に対する命令を人間でも理解しやすい形にしたものです。機械語に変換されると、ここもビット表記になるのですが、これを人間が手書きしようとすると CPU の仕様書も読む必要が出てきます。  
次に、オペコードの右側をオペランドと呼びます。このオペランドのシンタックスは CPU アーキテクチャ等によって異なり、今回ご紹介するのは「AArch64 アセンブリ記法」と呼ばれる記法で、「ARM アセンブリ記法」の64bit版です。詳細な用語説明は省略しますが、カンマを挟んで右から左にオペコードに準じた命令を実行してくれます。

これまでの解説を踏まえると、1行目は `5` を `X0` に `mov` すると読むことができます。 `mov` は値の移動を行う命令なので、レジスタの番地 `X0` に `5` を格納しているのだと分かります。これが四則演算を行う対象の整数のひとつで、もうひとつも同様に `X1` 番地に `4` を格納しています。  
なお、整数値の前にシャープを付けるのは、その数字がアドレス値ではないことを伝えるためのものです。

3行目では `add` というオペコードが使われています。これは加算命令で、第2オペランドと第3オペランドに格納された値を加算し、第1オペランドに指定したアドレスへ演算結果を格納することを示しています。同様の法則にしたがって、残りの演算を次に示します。

```s
mov X0, #2000   // レジスタ X0 に値 2000 を設定
mov X1, #1995   // レジスタ X1 に値 1995 を設定
sub X3, X0, X1  // レジスタ X3 に X0 - X1 の結果を設定

mov X0, #2      // レジスタ X0 に値 2 を設定
mov X1, #4      // レジスタ X1 に値 4 を設定
mul X4, X0, X1  // レジスタ X4 に X0 x X1 の結果を設定

mov X0, #10     // レジスタ X0 に値 10 を設定
mov X1, #2      // レジスタ X1 に値 2 を設定
udiv X5, X0, X1 // レジスタ X5 に X0 / X1 の結果を設定
```

### 2. 演算結果をASCIIコードに変換
演算結果を文字として出力するにはASCIIコードに変換する必要があります。実は、C標準ライブラリ内の `printf` 関数を利用すれば難しいことを考えずに済むのですが、ここはあえてアセンブリのみで実装することを考えてみましょう。ただし、さまざまな仕様に対応すると非常に複雑になってしまうため、まずは1桁の数字のみに対応する形で考えていきましょう。

```s
mov X0, #5
mov X1, #4
add X2, X0, X1
add X2, X2, #'0' // X2の値に文字 '0' のASCIIコード （48） を加算
mov W3, W2       // 32ビットのW2レジスタの値をW3レジスタにコピー
strb W3, [sp]    // W3の下位8ビットをスタックポインタの指すメモリアドレスにストア
```

上記のような処理を施すことでASCIIコードへの変換と標準出力するための準備が完了します。ちなみに、4行目では `0` のASCIIコードを加算できればよいので `add X2, X2, #48` と書くこともできます。そして、最後に使われている `strb` とは Store Register Byte の略で、指定されたレジスタの下位8ビット、つまり1バイトをメモリに格納する命令です。この命令の第1オペランドでは32ビットレジスタを指定する必要があるため、ASCIIコードに変換された計算結果が格納されている `X2` に対応する `W2` を一度作業領域 `W3` にコピーした後、`strb` 命令の第1オペランドに指定しているのです。  
改めてになりますが、こちらの方法では計算結果が1桁より大きくなる場合に正しく動作しなくなることに注意してください。なぜなら、ASCIIコードで表現できる数字は0から9までで、2桁以上になる場合はそれらの組み合わせて表現することになるからです。ですから、桁数に合わせてこちらの変換処理をループ処理することで複数の桁にも対応できることがわかります。

### 3. システムコールの把握
アセンブリで利用するシステムコールを把握するためには、Apple が提供する `syscalls.master` というファイル（opensource.apple.com/source/xnu/xnu-1504.3.12/bsd/kern/syscalls.master）が参考になります。このファイルには、利用可能なシステムコールの一覧が記載されています。  
今回は計算結果を表示したいので、標準入出力が可能な `write` システムコールが利用できそうです。次に `write` システムコールに関して記述された箇所を `syscalls.master` ファイルから抜粋しました。

```
4	AUE_NULL	ALL	{ user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte); }
```

この抜粋した行には、 `write` システムコールの情報が含まれています。まず、右端の部分にはシステムコールの定義があります。そして、左端の数値はシステムコールナンバーを示しており、アセンブリコード内ではこの番号を利用します。このように、定義から逆引きする形でシステムコールナンバーを特定することになります。  
なぜ、このような逆引きを行う必要があるのでしょうか。実は、アセンブリでシステムコールの単語表現をそのまま使用することができないのです。そのため、システムコールナンバーを調べる必要があるのです。初めはやや難解に感じるかもしれませんが、本稿を読み終える頃には「標準入出力はシステムコール4番」と即答できるようになっていることでしょう。

利用したいシステムコールが決まったら、その詳細な定義や使用方法を知るために `man` コマンドを利用することができます。具体的には、 `man` コマンドにシステムコール名を指定して実行します。ちなみに、 `man` コマンドの正体は `man man` で調べることができますが、コマンドのドキュメントを表示してくれるコマンドです。  
今回の場合、`man write` と実行します。このコマンドで得られるドキュメントには、システムコールの概要、引数の説明、戻り値、エラーコードなどが記載されています。これらを参考に補足を加えた定義内容を次に示します。

```c
{
    // - Parameters:
    //   - int: fd 入力は0、出力は1、エラーは2を指定
    //   - user_addr_t: cbuf
    //   - user_size_t: nbyte
    // - Returns:
    //   - user_ssize_t
    user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte);
}
```

シンタックスはC言語なので比較的読みやすいかと思います。これを見ると、 `write` 関数は3つの引数を受け取り、 `user_ssize_t` という型の戻り値を返すことがわかります。このように、日頃我々が使っている Swift のように、システムコールの呼び出し時には引数を渡すことができるのです。  
アセンブリでは、システムコールを実行する前にこれらの引数を明示的にレジスタに格納する必要があります。つまり、アセンブリコードを書く際には、これらの値を適切なレジスタにロードする必要があります。

```s
mov X0, #1    // レジスタ X0 に値 1 を設定
mov X1, sp    // レジスタ X1 にスタックポインタを設定
mov X2, #1    // レジスタ X2 に値 1 を設定
```

これまでの解説を踏まえると、1行目は `1` を `X0` に `mov` すると読むことができます。 `mov` は値の移動を行う命令なので、レジスタの番地 `X0` に `1` を格納しているのだと分かります。これが `write` システムコールの第一引数に渡したい値で、今回は文字列の「出力」を行いたいので `1` を指定しています。2行目も同様の命令で出力したい演算結果が格納されるスタックポインタを `X1` に格納しています。これが `write` システムコールの第二引数に渡したい値となります。
3行目では表示したい文字列の長さを指定していて、今回は1桁の半角数字なので `1` となっています。これが `write` システムコールの第三引数に渡したい値となります。

### 4. システムコールの実行
引数に渡す値をレジスタへ指定することができたので、実際にシステムコールを記述していきます。今まではレジスタの番地として `X0~5` を利用してきましたが、システムコールを行う時は特別な番地を使用する必要があります。

```s
mov X16, #4   // システムコールナンバーを 4 （write） に設定
svc #0x80     // Supervisor Call 命令でシステムコールを実行
```

システムコールを実行する際には、システムコールナンバーをレジスタ `X16` に設定します。ここでは、システムコールマスターファイルで確認した `4` を指定しているため、 `write` システムコールを実行するという意味になります。
`svc` 命令は「Supervisor Call」の略であり、システムコールを実行するための特別な割り込み命令です。この命令が実行されると、レジスタ `X16` に指定されたシステムコールナンバーに基づいて、カーネルが対応する処理を実行します。

### 5. プログラムの正常終了
プログラムの終了を、アセンブリでは明示的に記述する必要があります。終了処理にもシステムコールを使用するため、システムコールマスターファイルを確認します。該当箇所を次に抜粋します。  

```
1	AUE_EXIT	ALL	{ void exit(int rval); }
```

この情報から、システムコールナンバーが `1` で、終了ステータスを引数として受け取ることが分かります。もちろん、詳細な仕様は `man exit` コマンドを利用して確認することができます。これを利用した終了処理を次に示します。

```s
mov X0, #0   // 終了ステータスを 0 に設定
mov X16, #1  // システムコールナンバーを 1 （exit） に設定
svc #0x80    // システムコールを実行
```

いかがでしょうか。最初は読めなかったアセンブリも読めるようになってきたように感じませんか？今回は正常終了させたいので終了ステータスは `0` です。  
以上で文字列の標準出力を行うプログラムが完成しました。プログラムのエントリーポイント指定などを追加して実際に動作するようにしたコードを次に示します。

```s
.global _start
.align 2

_start:
    mov X0, #5
    mov X1, #4
    add X2, X0, X1
    add X2, X2, #48
    mov W3, W2
    strb W3, [sp]
    mov X0, #1 
    mov X1, sp
    mov X2, #1
    mov X16, #4
    svc #0x80

    mov X0, #2000
    mov X1, #1995
    sub X2, X0, X1
    add X2, X2, #48
    mov W3, W2
    strb W3, [sp]
    mov X0, #1
    mov X1, sp
    mov X2, #1
    mov X16, #4
    svc #0x80

    mov X0, #2
    mov X1, #4
    mul X2, X0, X1
    add X2, X2, #48
    mov W3, W2
    strb W3, [sp]
    mov X0, #1
    mov X1, sp
    mov X2, #1
    mov X16, #4
    svc #0x80

    mov X0, #10
    mov X1, #2
    udiv X2, X0, X1
    add X2, X2, #48
    mov W3, W2
    strb W3, [sp]
    mov X0, #1
    mov X1, sp
    mov X2, #1
    mov X16, #4
    svc #0x80

    mov X0, #0
    mov X16, #1
    svc #0x80
```

### 6. センブリをアセンブラでアセンブルする

```sh
vim calculate.s
as -arch arm64 \
    -o calculate.o calculate.s
```

ステップ5までで書いたアセンブリコードは拡張子が `s` のアセンブリファイルとして保存します。このファイルを `as` コマンドを利用してアセンブルすることでオブジェクトファイルを生成します。なお、今回 Apple Silicon で実行したいので、アーキテクチャ指定を arm64 としています。  
この段階では、まだリンクされていないので、生成されたオブジェクトファイルは実行不可能な中間ファイルとなります。

### 7. バイナリファイルの作成と実行

```sh
# lSystem option: システムライブラリをリンク
# syslibroot option: SDK パスを指定
# e option: エントリーポイントを _start に設定
# arch option: アーキテクチャを arm64 に指定
ld -o calculate calculate.o \
    -lSystem \
    -syslibroot `xcrun -sdk macosx --show-sdk-path` \
    -e _start \
    -arch arm64
./calculate
```

最後に、 `ld` コマンドを使用してオブジェクトファイルをリンクし、実行可能なバイナリを生成します。そして、 `./calculate` コマンドを実行することで、コマンドライン上に文字列が出力され、正常に終了することを確認できます。

以上がアセンブリコードからバイナリファイルを生成し、実行するための手順です。必要に応じて `man` コマンドを使用してオプションの詳細を確認してください。

---

最後までお読みいただきありがとうございます。  
当初は2桁以上の表示方法も紹介予定でしたが、予想以上のボリュームになってしまったため、半角数字1桁の標準出力までを解説させていただきました。できる限り丁寧な説明を心がけましたが、非常に難易度の高い内容に感じた方もいたかもしれません。ですが、今年の iOSDC はオフライン開催が予定されておりますので、ぜひ私を探して質問攻めしちゃってください。  

## 著者
Akio Itaya （akkey）

- AkkeyLab株式会社 代表取締役
- 株式会社AppBrew エンジニア
- 合同会社アイネット エンジニア

AkkeyLab は 板谷 晃良 の商標又は登録商標です
