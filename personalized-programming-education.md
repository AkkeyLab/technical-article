# Essence of Swift Education

## Introduction
“0と1しかわからない ワタシに"I"を教えてくれた”

これは初音ミクオリジナル曲の一つである「えれくとりっく・えんじぇぅ」に登場する歌詞の一部です。バーチャル・シンガーソフトウェアという存在である初音ミクは、作詞作曲・イラスト作成・3Dモデリングと様々な人によって命を吹き込まれ、多くの人に愛される存在になっています。このように私を生み出してくれてありがとう、愛してくれてありがとう、という感謝を伝えているのです。なんて素敵な歌詞なのでしょうか。  
ところで「0と1しかわからない」は本当なのでしょうか。初音ミクを「ソフトウェアを含めたコンピュータ全体」であると解釈すると本当だと言えるでしょう。つまり、皆さんがこれからプログラミングを学んで作ろうとしているのは0と1の塊であり、一般的にソフトウェアと呼ばれるものなのです。  
さて、皆さんは現時点で「プログラミング」に対してどのような印象をもっていますか？きっと多くの方が「何か難しそうだし、英語も勉強しないといけないんですよね？」と学習意欲を高めていることでしょう（？）。でも安心してください、先程の歌詞にあったように0と1さえわかっていれば良いのです。

0と1で表現される二値を二進数と呼び、二進法という法則に従って記述されます。これをコンピュータは、電気信号で解釈します。学生時代に理科の実験で利用した方も多いであろう豆電球で例えると、豆電球が点灯している状態を1、消灯している状態を0として解釈しているのです。  
次に、コンピュータが「10101110」という二進数を処理することを先程の豆電球で再現することを考えてみましょう。8個の豆電球を準備し、1の桁では点灯状態に、0の桁では消灯状態にすると良さそうです。さて、ここで点灯状態と消灯状態を表現するために行った操作に着目してみましょう。きっと、スイッチを用いて電源の電極と豆電球を接続したり切断するイメージをした方が多いのではないでしょうか。では、これをコンピュータはどのように行っているのでしょうか。まさか、初音ミクが手作業でスイッチを操作しているなんてことはないでしょう。もしそうだと仮定すると、この地球上で最も過酷な重労働を課せられている存在ということになってしまいます。なぜなら、コンピュータが1秒間に扱う二進数は億という単位にも及ぶからです。ということで実際には、トランジスタという半導体素子が電気信号を用いてスイッチ操作を行っているのです。CPUの進化を語るときにトランジスタの数や大きさが必ずと言っていいほど取り上げられるのはこれが理由です。  
ここまで、0と1をコンピュータが解釈する原理を説明してみました。もし、あなたがこの話題に強い興味を抱いたのであれば、本書で説明することの大半は朝飯前かもしれません。そんなあなたには、Swiftの魅力を伝える専門家として読み進めていただくことをお勧めします。逆に、もうお腹いっぱいだという方、ご安心ください。「0と1しかわからない」という単純に見えて超絶複雑なコンピュータとのコミュニケーション手段に革命をもたらしたのがプログラミング言語だったということを知っていただきたく、あえて難しい話題を取り上げたのです。とは言っても、プログラミングを学ぶ中で難所に遭遇することもあるでしょう。そんなときは、冒頭でご紹介したコンピュータの動作原理を読み返してみてください。きっと、これに比べれば我々人間が理解しやすいものであることに気づけるはずです。ぜひ、広い視野でプログラミングの世界を楽しんでください！

### Note
この書籍はSwift初心者が上達して一人前になるまでの間、何度も読み直すことを想定して執筆されています。そのため、1つの章の中だけでも文章を読むために必要となる技術レベルが大きく変化します。ですから、内容が難しいなと感じたら少し読み飛ばしてみてください。まずはざっくりとした解釈からで大丈夫です。  
また、本書はコーディングチュートリアルではないので、まずはSwift公式ドキュメント（docs.swift.org）やお好きな学習教材を使ってコーディングにチャレンジしてみてください。コツとしては、まずはプログラムを書いて動かしてみることでしょうか。どんなにシンプルなプログラムであっても、自分で作成したものが実際に目の前で動いたときの感動は格別です。こうしたコーディングを行っていく中で「動くのはわかったけど、なんで動くんだろう」という疑問が生まれてきたら本書をコーディングと並行して読み始めてみてください。  
そして、Swiftの真の魅力に気づいたあなたは、数多くのコーディングを経験する中で再度本書を読み返すタイミングがくることでしょう。それは、職場の後輩や新しくSwiftを学び始めた方々にSwiftの魅力を伝える側になったときです。きっとあなたは、初めて本書を読んだときとはまた別の学びを得ることができるはずです。

## Optional
“祝！マスターアップ！”

ソフトウェアのデバッグとそれに伴う不具合修正を終え、販売できる段階に到達したことをマスターアップと表現することがあります。これを祝うイベントを広報活動の一つとして取り入れる文化も存在していて、特にゲーム業界に多いようです。  
なぜマスターアップを顧客に対して大々的に祝うのでしょうか。それは、発売を楽しみにしている顧客が大勢いるからです。多額の先行投資によって開発が進行している間も全力の広報活動が繰り広げられ、顧客の期待は徐々に高まります。そんな顧客に対して発売延期や仕様変更、価格改定を発表するという苦渋の決断を迫られる現場も少なくないという現実があるのです。こうした苦難を共にした企業と顧客はもはや一心同体となっており、マスターアップという記念すべき日を迎えられたことを共に心から祝うのです。  
では、明日発売予定だったゲームソフトの発売延期が突然発表されたとしたら、あなたはどのような反応をしますか？この発売日に合わせて有給休暇を取得していたら？毎日全力で節約して購入費用を貯めてきたとしたら？きっと、一時的に思考が停止してしまう人もいるのではないでしょうか。これと同じような現象がプログラム実行中にも発生するのです。そして、それを防ぐ機能がSwiftには実装されており、その名をオプショナルと言います。

列挙型で定義されたオプショナル型はsomeとnoneという2つのケースをもっています。これによって、値が存在する場合と存在しない場合を表現することが可能です。例えば、オプショナルな整数を表現するには`Optional<Int>`と書くことができ、これを変数の型に指定した場合には、何らかの整数が代入される可能性とnilが代入される可能性があることを表現することができます。ですから、オプショナルな変数を使うことで、nilである可能性に配慮しなければならないことを言語レベルで強制されるのです。このオプショナルは一般的に疑問符を使って書かれることが多く、`Int?`と書きます。ちなみに、列挙型を意味するenumはenumerationの略で、値に名前をつけたケースという単位でグループ化できるSwiftの言語機能です。  
さて、先程ご紹介した「突然のゲームソフト発売延期事件」を元に噛み砕いていきましょう。突然の発売延期に大きなショックを受けてしまったのは、ゲームの発売日が変わらないことを前提に有給休暇を取得していたからでした。なので、発売日が変更される可能性を考慮して代わりの新作ゲームソフトを準備しておくなどの対策をしておくと、受けるショックを最小限に抑えることができたかもしれません。つまり、発売予定日に発売される可能性と発売されない可能性を事前に考慮しておくことが重要で、これをSwiftではオプショナルという型で表現できるのです。  
しかし、マスターアップ後に発売日が変更されるケースは非常に稀なので、発売延期を考慮する必要性は低くなりそうです。このように、ときにはこのオプショナルという状態から抜け出したくなるときがあります。そんなときは、アンラップを行うことになります。アンラップという用語は、オプショナルで値を表現するときに「その値をラップする」と表現することからきています。具体的には、オプショナルなインスタンス変数からインスタンスプロパティであるunsafelyUnwrappedにアクセスすることでアンラップされた値を得ることができます。このアンラップは一般的に感嘆符を使って書かれることが多く、`Optional.some(174)!`と書けます。ただし、これは強制アンラップと呼ばれるもので、その値がnilだった場合にはアプリケーションがクラッシュしてしまいます。これを防ぐには、オプショナルバインディングもしくはnil合体演算子を活用したアンラップを行う必要があります。  
オプショナルバインディングとは、if文やguard文を用いてnilであるかの確認を行うと同時にアンラップまで行う方法です。対してnil合体演算子とは、nilだった場合のデフォルト値を指定する方法です。値の有無で実行処理が変化する場合は前者を、値がなかったとしてもデフォルト値を使って共通の処理を実行する場合は後者を利用するケースが多いです。

## Protocol
“Can I have this one, please?”

海外旅行で英語圏に行くと必ず使うであろうフレーズの一つです。海外旅行経験者から「これさえ覚えておけば良いフレーズ」として教わった方も多いかもしれません。英語に苦手意識があって、尚且つ実践的な英会話経験がない方にとって「英語を話せなくてもなんとかなる」という経験者からのアドバイスは、にわかには信じがたいものだと思うことでしょう。もちろん、話せない度合いの解釈が人によって異なっている可能性を考慮する必要がありますが、英語が苦手でも海外旅行を満喫している方は少なくないように感じます。この要因の一つとして、生活環境における共通点の多さが挙げられるでしょう。  
例えば、レストランに行くと店員さんに席を案内してもらい、次の手順を踏むことが多いでしょう。

1. メニューを見る
2. お店のスタッフに注文内容を伝える
3. 食事をする
4. お会計をする

もちろん、チップ文化の有無など、小さな違いはありますが、この基本手順が採用されている国や地域は多いでしょう。このような文化は様々な歴史的背景から一般化したものであるとともに、現代の人々がレストランの基本として期待しているものです。ですから、必要最低限のコミュニケーションでもレストランでの食事を楽しむことができるのです。こうした手順について定めたものを一般的にプロトコルと言い、新規でレストランを開業しようとする経営者もこのプロトコルに準拠しつつ、自社独自のオリジナリティをもたせるのです。このような表現をプログラム上で実現させる機能がSwiftには実装されており、その名をプロトコルと言います。

プロトコルはクラスや構造体、列挙型などに対して特定のプロパティやメソッド、イニシャライザの実装を約束させるための言語機能です。まず、プロパティといってもその種類は複数存在し、インスタンスが値を保持するStored Properties、値を保持せずに都度返却内容を計算して返すComputed Properties、インスタンスから独立して値を保持するType Propertiesが代表的なものとして挙げられます。Stored Propertiesでの実装を想定する場合は、アクセス権限として読み取り専用なのか読み書き可能なのかをプロトコルで指定することになります。逆にComputed Propertiesでの実装を想定する場合は、値を保持しないので読み取り専用として指定することが多いですが、Setterを明示的に定義して読み書き可能とすることもできます。これらに加えてType Propertiesとして実装することを想定する場合には、静的プロパティであることを示すstatic修飾子を付与します。  
次に、メソッドはfuncキーワードから始まり、メソッド名、引数名、引数の型から成る処理群です。プロトコルではメソッドの定義のみで、実装を含まないことに注意してください。なお、プロトコルでのメソッド定義では、外部引数名と内部引数名の区別を指定することができます。つまり、外部引数名と内部引数名の両方を指定することができることになります。  
最後にクラスと構造体、そしてイニシャライザに関してご紹介します。クラスは参照型で構造体は値型であるという大きな違いがあり、この違いはC言語に代表されるポインタを扱う言語で特に意識することの多い概念です。では、参照型と値型という違いがポインタとどのような関係にあるのでしょうか。まず、ポインタはメモリ上の特定の場所を示すために使用される値のことを言います。そして、クラスや構造体を変数や定数に代入したとき、そのデータはメモリ上の何処かに保存されており、その保存場所を指し示すのがポインタというわけです。したがって、参照型のインスタンスを使用する場合、変数や定数は実際のデータへのポインタを保持することになります。逆に、値型のインスタンスを使用する場合、変数や定数は実際のデータそのものを保持し、それを別の変数に代入する際には、コピーされたデータが代入されることになります。このように、クラスと構造体は異なる挙動を示すため、仕様と実際の実装を元に適切な一方を選択して利用する必要があります。例えば、クラスは複数箇所で共有されるデータやオブジェクトの状態を管理する際に便利ですが、複数の場所でその値が変更される可能性を考慮した実装が求められます。一方、構造体は値のコピーが行われるため、データが小さなスコープ内のみで利用される場合やイミュータブルなデータ構造を扱う場合に適しています。  
そしてイニシャライザとは、クラスや構造体を初期化するために利用されるメソッドの一種で、インスタンス化に必要な初期値の設定などを行います。例えば、iOSにおけるUIViewControllerはクラスとして定義されているため、イニシャライザが利用可能です。

ここまで、プロトコルが実装のルールを定義することができる言語機能であり、プロパティやメソッド、イニシャライザの定義を細かく指定できることをご紹介しました。では、これには一体どんな利点があるのでしょうか。それは、クラスや構造体を抽象化できることにあります。抽象化により、クラスや構造体間の強い依存を弱めることが可能になり、コードの可読性を高めることができます。この特性の活用術は様々で、例えば単体テストの書きやすい実装法に活用されています。  
さて、先程ご紹介した「海外のレストラン」を元に噛み砕いていきましょう。メニューから食べたいものを選んで、会計をするという手順は国や言語が違ったとしても同じで、これが抽象化された状態にあたります。逆に、もう少し詳しく見ていくと、海外にはチップを支払う文化があり、一度支払いを済ませたあとにレシートの金額を訂正する形でチップを支払うことがあります。更に、日本国内でも券売機で先に支払いを済ませるスタイルや、席でタブレット端末を操作して注文や決済を済ませるスタイルなど、レストランの数だけ利用スタイルが存在しています。これがプログラムにおける実装で、具体化されたものと言えます。このように、抽象化された情報は、初めて海外に行く友人にアドバイスするときにも伝えやすいですし、その友人が実際に海外のどのレストランで食事をしたとしても共通して役立つ情報となることでしょう。これこそ、抽象化と依存分離の利点と言えるでしょう。

Appleは年に一度WWDCという技術者向けのイベントを開催しています。その中ではSwiftに関する最新情報の発表も行われ、直近ではオンラインで全世界へ同時配信されています。更に、Apple本社のあるカリフォルニアにてオフライン形式でWWDCに参加する機会が提供されることもあります。このオフラインイベントは例年抽選による招待となっており、限られた人のみが参加できる非常に貴重な機会であることで知られています。本書を読んでくださっている皆さんにはぜひ、このオフラインイベントへの参加にチャレンジしていただきたいです。英語が苦手という方もご安心ください、全世界共通のプロトコルは必ずありますから。

## Delegation Pattern
“ただの人間には興味ありません。この中に宇宙人、未来人、異世界人、超能力者がいたら、あたしのところに来なさい。”

これは涼宮ハルヒシリーズに登場するメインヒロイン、涼宮ハルヒが実際に作中で口にした自己紹介の一部です。そんな彼女が団長を務めるSOS団には普通の人間とはかけ離れた独特なメンバーが入団しています（1人の例外を除いて）。そんな団員メンバーは、涼宮ハルヒの特殊能力の暴走を防ぐため、彼女の様々な要求に応じていくことになります。涼宮ハルヒシリーズは、ライトノベルを原作としてアニメ化や映画化も果たしている人気作品ですので、プログラミングで苦戦したときの息抜きとして観てみてはいかがでしょうか。長門有希の神がかったタイピングに負けまいとやる気が漲ってくることでしょう。
さて、涼宮ハルヒが対等に会話できる相手が限られるように、プログラム上でも特定の条件に合致しない限り実行できない処理というものが存在します。それがデリゲーションであり、その手法をデリゲーションパターンと呼びます。これは、Swiftの言語機能そのものを示すものではなく、デザインパターンと呼ばれる設計手法を示す用語です。デザインとは設計のことで、パターンとは言語化された雛形を示します。つまり、言語化された再利用可能な設計手法に名前が付いたものということです。Appleが提供するAPIには、Delegateという単語が含まれるものがあるため、特定の機能を示すものであると誤解してしまいがちなので注意しましょう。

Appleからは、リスト表示を実現するUICollectionViewが提供されており、主にObjective-Cという言語で書かれていることが知られていますが、その実装内部は一般公開されていません。実装に使われているプログラミング言語は異なりますが、UIKitを担当するエンジニアの手によって実装されているという点では、我々のコーディングとの共通点も多いはずです。ですから、UICollectionView内部でもデリゲーションパターンが採用されており、その証拠にUICollectionViewDelegateというプロトコルが提供されています。  
では、UICollectionViewDelegateについて少し見ていくことにしましょう。このプロトコルに定義されているメソッドの一つに`collectionView(_:shouldSelectItemAt:)`があります。これは、ユーザがセルをタップしたときに呼ばれるメソッドで、選択したとみなすか否かを示す真偽値を返します。つまり、ユーザのアクションから表示内容を変化させるインタラクションをコントロールするためのプロトコルであるということです。  
次に、これがデリゲーションパターンを用いて実装されている理由について見ていきましょう。デリゲーションとは処理の委譲を意味する言葉で、先程の例ではインタラクションを決定する処理を委譲するためにデリゲーションパターンを活用しているということがわかります。では、誰に処理を委譲しているのでしょうか。それはUICollectionViewを使う実装側で、主に本書を読んでくださっている皆さんです。Appleが提供するUICollectionViewはユーザからの操作命令を適切に処理し、実装された命令通り画面に反映するところまでを担当し、実際にどのようなインタラクションを行うかという実装は我々デベロッパに委ねられているのです。これがデリゲーションパターンを用いて実装されている理由です。

ここからは、あなたがエンジニアとしてAppleに入社したと仮定してデリゲーションパターンを実装に落とし込む方法についてご紹介します。さっそく、そんなあなたに「`IndexPath(item: 0, section: 0)`のセルだけを強調表示する機能をUICollectionViewに実装してほしい」という仕事が舞い込んできたらどのように実装しますか？もちろん、それだけだと仕様として情報不足すぎですし、そもそもUIKit内部のコードは公開されていないのでイメージだけで問題ありません。まず、全体のイメージとしては、次のようになるでしょう。

1. タップされたセルのインデックスを判定
2. インデックスに応じたセルの生成を委譲
3. 返却されたセルが`IndexPath.zero`であればボーダーを付けて強調
4. 最終的なセルを引数に指定してレイアウト担当メソッドを呼ぶ

今回、デリゲーションパターンを説明するうえで重要になるのはステップ2でしょう。まず、処理を委譲するためにはインプットとアウトプットを明確にする必要があります。今回は、インプットがIndexPathでアウトプットがUICollectionViewCellになりそうです。次に、これを実装に落とし込む方法ですが、委譲相手が実態として存在しないことに注意する必要があります。なぜなら、今開発しているのはAppleが提供するUIKitの新機能であり、このUICollectionViewを使う側である委譲相手に直接干渉することは不可能だからです。そんなときに役立つのが前章で紹介したプロトコルです。UICollectionViewを使ってアプリを開発するデベロッパに「IndexPathを伝えるから、それに該当するUICollectionViewCellを返して」というルールをプロトコルで定義するのです。実は、このようなプロトコルは既に存在しており、UICollectionViewDataSourceプロトコルに`collectionView(_:cellForItemAt:)`として定義されています。プロトコル名にDelegateが付いていませんが、デリゲーションパターンが活用されていることに違いはありません。  
今回実装したい機能に近いものはAppleによって実装済みだったので、それを改良する形で実装していくことにしましょう。まず、UICollectionViewには`weak var dataSource: (any UICollectionViewDataSource)? { get set }`というプロパティが定義されており、ここに代入されたオブジェクトはプロトコルに準拠していることが保証されています。ですから、インデックスに応じたセルの生成を委譲するには`let cell = dataSource.collectionView(self, cellForItemAt: index)`という処理を書けばよいことがわかります。あとは、インデックスがゼロであった場合にボーダーを付ける処理を付けるだけで完成です。
さて、先程ご紹介した「涼宮ハルヒ」を元に噛み砕いていきましょう。まず、涼宮ハルヒが団員メンバーに様々な無理難題を要求することは委譲と呼べるでしょう。しかし、そんな彼女が変わりものであることもあり、対等に会話できる相手は限られます。つまり、宇宙人もしくは未来人、または超能力者であるというプロトコルに準拠していなければ委譲することはできないのです。

## Asynchronous
“ただいま180分待ち”

これをSwiftで表現するには`DispatchQueue.main.asyncAfter(deadline: .now() + 180 * 60) { /* do something */ }`と書けそうです。というのは冗談で、皆さんはテーマパークのアトラクションで最長どれくらい待ったことがありますか？調べたところによると東京ディズニーランド内でのアトラクション待ち時間が10時間を超えたことが過去にあったようです。流石に10時間となってくると話が変わってきそうですが、東京ディズニーリゾートでは、アトラクションの待ち時間も私達を楽しませてくれる工夫が数多く準備されています。例えば、アトラクションの世界観に合わせた洞窟の装飾が待機場所に施されていたり、ストーリーの映像とともに注意事項を伝える映像を投影するなど、退屈するどころか更にワクワクさせてくれるような工夫が何段階にもわたって施されています。これは、アトラクションというメインコンテンツを稼働させながら非同期的にチュートリアルというサブコンテンツを提供するというマルチスレッド戦略が採用されているとも言えるかもしれません。
さて、テーマパークのアトラクションに非同期処理が施されていたように、プログラム上でも処理を非同期的に行う方法が存在します。ここでは、Swiftで非同期処理を実現する方法として、次に3つをご紹介します。

1. Escaping Closures
2. Combine
3. Concurrency

Escaping Closuresとは、`@escaping`属性を付与したクロージャです。これはメソッドの引数として渡されますが、メソッドが返却値を返したあとで実行される可能性がある特殊なクロージャなのです。つまり、`@escaping`属性が付与されたクロージャはEscaping Closuresであり、それは非同期的に実行される可能性を示しているということになります。ちなみに、クロージャと似た言語機能は他のプログラミング言語にも存在しており、ラムダ式や無名関数と呼ばれます。Swiftの場合でも、特に無名関数と呼ぶとイメージがしやすく、funcキーワードやメソッド名が省略された状態に近いシンタックスとなっています。さらに、通常のメソッドと違い、クロージャは変数への代入や定数としての定義が可能だったり、メソッドの引数に指定できるといった明確な違いをもっています。  
次に、Combineはフレームワークという形でAppleから提供されているもので、非同期処理を宣言的に書くためのAPIが数多く含まれています。サードパーティ製ライブラリであるRxSwiftとも似た設計思想になっていることから、RxSwiftからCombineへの移行という技術トピックに注目が集まったこともあります。このCombineやRxSwiftはリアクティブプログラミングという思想に強く影響を受けており、データの変化や外部からのイベントを検知すると、事前に定義されたルールやパターンに基づいて振る舞いを決定するという特徴をもっています。  
最後に、Concurrencyはasyncとawaitキーワードを利用した非同期処理を実現するための言語機能です。シンタックスの観点では同期処理を記述する感覚に近く、awaitキーワードを使って非同期関数を呼び出すと、それ以降の行では非同期処理が完了した前提でプログラムを書くことができます。つまり、awaitによってプログラムの実行はその行で一時停止するのです。しかし、処理自体は非同期的に実行されているため、メインスレッドをブロックしてしまう心配はありません。このようなシンタックスの変化によって、クロージャによる非同期処理で課題となっていたネスト問題が発生しなくなりました。ちなみに、asycnとはAsynchronousの短縮形で、非同期関数を定義する際に用いるキーワードです。同じようにawaitは非同期関数の結果が返ってくるのを待つ際に用いるキーワードです。

では、非同期処理がなぜ必要なのか、改めて考えてみることにしましょう。まず、非同期処理を一切行わないということは、メインスレッドのみで全ての処理を行うことを意味します。そして、その処理は1つずつ順番に処理されるため、1つの処理に時間がかかってしまうと以後の処理に大きな影響を及ぼすことになります。したがって、実行時間が長くなる処理をメインスレッドのみで実行すると、アプリケーションがフリーズしてしまうのです。例えば、技術書典のウェブページで本を検索したとき、検索結果が取得できるまでローディングアニメーションも動かず、画面のスクロールやボタン操作などありとあらゆる機能が一時的に使用不能となってしまうのです。これではユーザ体験を大きく損ねてしまうため、メインスレッド以外に複数準備されているサブスレッドに非同期処理を担当させるのです。こうすることで、UIに関する処理を担当するメインスレッドで処理の渋滞が発生しにくくなり、アプリケーションがフリーズしてしまうことを防ぐことができるのです。

## visionOS
“Spatial Computing”

iPhoneやMacで知られるAppleから空間コンピュータという新しいジャンルの製品が発表されました。その名をApple Vision Proと言い、一般的に複合現実ヘッドセットと呼ばれる製品です。これには専用のOSであるvisionOSが搭載されていますが、アプリ開発者が拒否した場合を除いてiOS,iPad向けのアプリも利用可能です。更に、Macとの連携機能も標準搭載されています。Apple Vision Proは2024年2月2日に米国で販売が開始されており、他の国での発売も順次進めると発表されています。

visionOS向けの開発では三次元空間を扱うこともあり、なんとなく難しいイメージをもっている方も多いかもしれません。しかし、SwiftUIによるパワフルな設計スタイルのお陰でiOSなどで培った設計スキルを最大限活かすことができるのです。最後の章として、Swiftを新しく学ぶように、visionOSを新しく学ぶ方に向けて、三次元オブジェクトを表示するアプリケーションを題材にvisionOSでの開発ノウハウをご紹介します。  
まず、三次元オブジェクトはUSDZというフォーマットで準備する必要があります。USDZとはUniversal Scene Description ZIPの略で、USDファイルを非圧縮ZIP化したものです。実は、2018年のWWDCで発表されたフォーマットで、visionOS登場前からこのファイル形式をApple製品では標準サポートしてきました。皆さんは、Mac Proのような高額で魅力的なApple製品をARでデスクの上に表示して楽しんだことはありますか？このとき利用されている三次元オブジェクトこそ、USDZファイルなのです。このファイルには数多くの情報を保存することが可能で、アニメーションやライティング、テクスチャを含めることも可能です。ですから、三次元オブジェクトを動かしたい場合にはUSDZファイルにアニメーション情報を複数組み込んでおき、そのアニメーションを取得して任意のタイミングで再生するプログラムを書くことになります。そんなUSDZファイルを作成する方法としては、Appleが提供するReality ComposerやBlenderなどのモデリングソフトウェアを利用する方法がありますが、まずはSketchfabなどで提供されている完成品で試してみるのもよいでしょう。  
さっそく三次元オブジェクトを表示してみましょう。まず、USDZファイルをプロジェクトの任意のディレクトリに格納し、Model3D構造体の引数にそのファイル名を指定します。これは、SwiftUIのViewとして扱うことができるので、あとは`var body: some View { /* do something */ }`に指定するだけで表示できてしまいます。次に、三次元オブジェクトをアニメーションさせるにはModel3D構造体ではなくRealityView構造体を使う必要があります。三次元オブジェクトはModelEntityクラスを利用して取得し、RealityView構造体のContentに追加することになります。このModelEntityクラスはEntityクラスを継承しており、Entityクラスに定義されているavailableAnimationsプロパティ経由で再生可能なアニメーションを取得することができます。アニメーションはAnimationResourceクラスの配列で取得できるため、任意のアニメーションを選択し、EntityクラスのplayAnimationメソッドに指定することで再生が可能になります。  
いかがでしょうか。今回は特にシンプルな実装をご紹介しましたが、サンプルコードがなくてもイメージできるほど親和性のある実装手順だと感じていただけたのではないかと思います。

今回ご紹介したアプリケーションの実装例は次のリポジトリから確認することができます。  
github.com/AkkeyLab/zenith

## Conclusion
visionOSセクションを除き、全ての章で現実世界の例えを元にSwiftの言語機能をご紹介しました。もちろん、コンピュータ上で動くという特性上、現実世界には存在しない概念も存在しますが、多くの言語機能が私達の身の回りにある原理と似たアプローチを採用しています。これは、0と1のようなコンピュータが解釈しやすい表現と人間が理解しやすい表現との間にある大きな壁を無くしたいというプログラマーがもつ共通認識によるものなのです。本書を通してプログラミングが好きだと心から思える人が一人でも増えたら嬉しいです。
