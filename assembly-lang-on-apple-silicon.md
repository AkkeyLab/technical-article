# Apple Silicon のためのアセンブリ入門

## Introduction
Apple Silicon、皆さんはどれくらい使い倒していますか？
現代の令和においても、我々は CPU と非常に近い距離で対話する手段を持っています。それがアセンブリです。
アセンブリは機械語に非常に近い低水準言語であり、CPU アーキテクチャによって記述方法も異なります。Swift などの高水準言語では記述方法が言語のバージョンアップ以外で変わることは少ないため、この特性に疑問を持つ人もいるかもしれません。

本稿では、アセンブリを通じて Apple Silicon を操作する方法を紹介します。初めは仕事に直接活かせないように思えるかもしれませんが、Apple Silicon と近い距離で対話することは意義深いものです。きっと Apple Silicon がさらに魅力的に感じられるでしょう！

## 前提
本稿では基礎知識の無い方にも読んでいただけるように心がけて執筆いたしました。そのため、例外を省略して説明している箇所があります。  
例えば「Apple Silicon のため」と言っても、ARMアーキテクチャを採用した CPU に共通するもので、他社製品にも通用する事柄だったりします。

しかし、内容の間違いや誤解を招く表現が含まれてしまっているかもしれません。本稿は GitHub で管理されており、最新の状態が閲覧できるだけでなく、皆様からのご指摘にも対応可能となっております。ぜひ、ご活用ください。  
GitHub: https://github.com/AkkeyLab/technical-article

## アセンブリとは
皆さんは「ファービー」という玩具をご存知ですか？アメリカの Tiger Electronics が1998年に発売し、日本では株式会社タカラトミーから販売されました。この玩具は、筐体に内蔵された各センサーからの入力を元に会話や歌を披露してくれるというもので、当時多くの注目を集めました。  
実はこの初代ファービー、アセンブリという言語でプログラミングされていたことが分かっています（※1）。

この言語のことを、アセンブラ言語と呼ぶこともあるようですが、本稿ではアセンブリ言語と表現し、アセンブリで書かれたプログラムを機械語に変換するツールをアセンブラと呼ぶことにします。つまり、アセンブリをアセンブラでアセンブルするのです。

## Hello, World!
1. 利用するシステムコールの把握
2. システムコールの引数に指定する値をレジスタに格納
3. システムコールの実行
4. プログラムの正常終了
5. `as` コマンドでアセンブルしてオブジェクトファイル（拡張子 `o`）を生成
6. `ld` コマンドでリンクしてバイナリ（実行可能ファイル）を生成

今回、上記6ステップでアセンブリでのコーディングから実行までを行います。  
ここで、システムコールという用語が多く登場していることに気づくかと思います。実は、機械語に近いアセンブリであっても、CPU を自由自在に操作できるわけではなく、カーネルに対してシステムコールという命令を行うことで処理を実行することになります。これは Swift で `print` 関数を用いて標準出力を行う感覚に近いかもしれません。

### 1. 利用するシステムコールの把握
準備されているシステムコールの一覧は Apple から `syscalls.master` というファイル（※2）で公開されています。今回は `Hello, World!` の文字列表示を行いたいので、標準入出力が可能な `write` というシステムコールを利用することにします。

```
4	AUE_NULL	ALL	{ user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte); }
```

上記に `write` について記述された行を抜粋しました。システムコール一覧には様々なカラムが存在しますが、ここでは両端の要素に着目してみましょう。左端はシステムコールナンバーが示されており、アセンブリではこの番号を使うことになります。そして、右端がシステムコールの定義となります。我々はこの定義から使いたいシステムコールナンバーを探すことになります。  
このように、 `write` という単語表現をそのまま利用することができない点もアセンブリが難解だと感じる要因の一つになっています。

### 2. システムコールの引数に指定する値をレジスタに格納

```sh
man write
```

利用するシステムコールが決まったら、システムコールマスターファイルの定義を元にアセンブリを書いていくことになります。しかし、肝心の定義内容は最低限であるため、 `man` コマンドを利用して詳細を調べます。  
補足を加えた定義内容を以下に示します。


```c
{
    // - Parameters:
    //   - int: fd 入力は0、出力は1、エラーは2を指定
    //   - user_addr_t: cbuf
    //   - user_size_t: nbyte
    // - Returns:
    //   - user_ssize_t
    user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte);
}
```

シンタックスはC言語なので比較的読みやすいかと思います。これを見ると、3つの引数を取り、1つの戻り値があることが分かります。このように、日頃我々が使っている Swift のように、システムコールの呼び出し時には引数を渡すことができるのです。  
アセンブリでは、引数に渡す値も明示的にレジスタへ格納してあげる必要があります。ですから、システムコールを行う前に上記で確認した3つの値をレジスタへ格納します。

```s
mov X0, #1
adr X1, greeting
mov X2, #16

greeting: .ascii "Hello, AkkeyLab\n"
```

3つの引数をレジスタに格納するコードは上記のようになります。  
これは `AArch64 アセンブリ記法` と呼ばれる記法（※3）で `ARM アセンブリ記法` の 64bit 版です。左からニーモニックと呼ばれる命令、レジスタ、命令の対象となる値、という順番で書かれています。  
なので、 `mov X0, #1` は `1` を `X0` に `mov` すると読むことができます。 `mov` は値の移動を行う命令なので、レジスタの番地 `X0` に `1` を格納しているのだと分かります。これが `write` システムコールの第一引数に渡したい値で、今回は文字列の「出力」を行いたいので `1` を指定しています。  
なお、整数値の前にシャープを付けるのは、その数字がアドレス値ではないことを伝えるためのものです。

2行目では `adr` という命令が利用されています。これは Address の略で、シンボルのアドレスをレジスタへ格納するためのものです。ここでは `greeting` というラベルを指定しており、Swift における変数定義のように扱うことができます。つまり、 `greeting: .ascii "Hello, AkkeyLab\n"` で表示したい文字列をラベルを経由して指定していることが分かります。これが `write` システムコールの第二引数に渡したい値となります。

3行目は1行目と同じ `mov` 命令で、表示したい文字列の長さを指定しています。改行コードを1文字としてカウントしている点に注意しましょう。これが `write` システムコールの第三引数に渡したい値となります。

### 3. システムコールの実行
引数に渡す値をレジスタへ指定することができたので、実際にシステムコールを記述していきます。今まではレジスタの番地として `X0~2` を利用してきましたが、システムコールを行う時は特別な番地を使用する必要があります。

```s
mov X16, #4
svc #0x80
```

システムコールを行う時はレジスタ `X16` にシステムコールナンバーを指定します。初めにシステムコールマスターファイルで確認した `4` を指定することで `write` を実行します。  
`svc` 命令は Supervisor Call の略で、システムコールを実行するための特殊な割り込み命令です。これが呼ばれた時、レジスタ `X16` に指定されたシステムコールナンバーに従った処理をカーネルに対して実行します。

### 4. プログラムの正常終了
アセンブリではプログラムの終了も明示的に記述する必要があります。  
まず、システムコールマスターファイルを見ると以下のようなシステムコールがあることが分かります。

```
1	AUE_EXIT	ALL	{ void exit(int rval); }
```

これは、システムコールナンバーが `1` で、終了ステータスを引数に指定する必要があると読み取ることができます。もちろん、詳細は `man exit` で調べることができます。以下にこれを利用した終了処理を示します。

```s
mov X0, #0
mov X16, #1
svc #0x80
```

いかがでしょうか。最初は読めなかったアセンブリも読めるようになってきたように感じませんか？今回は正常終了させたいので終了ステータスは `0` です。  
以上で文字列の標準出力を行うプログラムが完成しました。プログラムのエントリーポイント指定などを追加して実際に動作するようにしたコードを以下に示します。

```s
.global _start
.align 2

_start:
    mov X0, #1 
    adr X1, greeting
    mov X2, #16
    mov X16, #4
    svc #0x80
    mov X0, #0
    mov X16, #1
    svc #0x80

greeting: .ascii "Hello, AkkeyLab\n"
```

### 5. `as` コマンドでアセンブルしてオブジェクトファイル（拡張子 `o`）を生成

```sh
vim greeting.s
as -arch arm64 \
    -o greeting.o greeting.s
```

ステップ4までで書いたアセンブリコードは拡張子が `s` のアセンブリファイルとして保存します。このファイルを `as` コマンドを利用してアセンブルすることでオブジェクトファイルを生成します。なお、今回 Apple Silicon で実行したいので、アーキテクチャ指定を arm64 としています。  
このオブジェクトファイルはリンク前なので、この段階では実行することができない中間ファイルとなります。

### 6. `ld` コマンドでリンクしてバイナリ（実行可能ファイル）を生成

```sh
ld -o greeting greeting.o \
    -lSystem \
    -syslibroot `xcrun -sdk macosx --show-sdk-path` \
    -e _start \
    -arch arm64
./greeting
```

最後に `ld` コマンドでリンクを行い、生成されたバイナリを実行してみましょう。コマンドライン上に文字列が出力されるとともに正常終了することが確認できるかと思います。コマンドオプションに関しては `man` コマンドで確認することが可能です。

## 様々な記法
標準出力の方法について学んだところで、本稿のタイトルを思い出してみましょう。これは本当に Apple Silicon 特有のものなのでしょうか。Intel CPU を搭載した旧 MacBook でも実行できてしまえば、軽くタイトル詐欺ということになります。

---

最後までお読みいただきありがとうございます。  
文系・理系関係なく楽しんでいただけるように執筆したと初めに書きましたが、非常に難易度の高い内容に感じた方もいたかもしれません。ですが、今年の iOSDC はオフライン開催が予定されておりますので、ぜひ私を探して質問攻めしちゃってください。  
また、本稿は GitHub で管理されておりますので、気軽に issue などの形で質問や修正依頼いただけますと幸いです。

※1: http://www.seanriddle.com/furbysource.pdf  
※2: https://opensource.apple.com/source/xnu/xnu-1504.3.12/bsd/kern/syscalls.master  
※3: [Apple Silicon から学ぶ CPU の歴史](https://github.com/AkkeyLab/technical-article/blob/main/cpu-history.md)

## 著者
- AkkeyLab株式会社 代表取締役
- 株式会社AppBrew エンジニア
- 合同会社アイネット エンジニア

本稿執筆時点で3社に所属するプログラマー兼経営者。  
緑の毛色が特徴の初代ファービーを両親に買ってもらって遊んだのが良い思い出。遊んでいる間に何をしてもすぐに寝てしまうようになってしまい、乾電池を抜いてしまった。アセンブリを読めば、なぜすぐ寝てしまうのか解読できるのかもしれませんね。
