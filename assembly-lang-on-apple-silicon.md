# Apple Silicon のためのアセンブリ入門

## Introduction
Apple Silicon、皆さんはどれくらい使い倒していますか？
現代の令和においても、我々は CPU と非常に近い距離で対話する手段を持っています。それがアセンブリです。
アセンブリは機械語に非常に近い低水準言語であり、CPU アーキテクチャによって記述方法も異なります。Swift などの高水準言語では記述方法が言語のバージョンアップ以外で変わることは少ないため、この特性に疑問を持つ人もいるかもしれません。

本稿では、アセンブリを通じて Apple Silicon を操作する方法を紹介します。初めは仕事に直接活かせないように思えるかもしれませんが、Apple Silicon と近い距離で対話することは意義深いものです。きっと Apple Silicon がさらに魅力的に感じられるでしょう！

## 前提
本稿では基礎知識の無い方にも読んでいただけるように心がけて執筆いたしました。そのため、例外を省略して説明している箇所があります。  
例えば「Apple Silicon のため」と言っても、ARMアーキテクチャを採用した CPU に共通するもので、他社製品にも通用する事柄だったりします。

しかし、内容の間違いや誤解を招く表現が含まれてしまっているかもしれません。本稿は GitHub で管理されており、最新の状態が閲覧できるだけでなく、皆様からのご指摘にも対応可能となっております。ぜひ、ご活用ください。  
GitHub: https://github.com/AkkeyLab/technical-article

## アセンブリとは
皆さんは「ファービー」という玩具をご存知ですか？アメリカの Tiger Electronics が1998年に発売し、日本では株式会社タカラトミーから販売されました。筐体に内蔵された各センサーからの入力を元に会話や歌を披露するというもので、爆発的販売台数を記録しました。  
実はこの初代ファービー、アセンブリでプログラミングされていたことが分かっています（※1）。

アセンブラ言語と呼ぶこともあるようですが、本稿ではアセンブリ言語と表現し、アセンブリで書かれたプログラムを機械語に変換するツールをアセンブラと呼ぶことにします。つまり、アセンブリをアセンブラでアセンブルするのです。

※1: http://www.seanriddle.com/furbysource.pdf

## Hello, World!
1. ソースファイル（拡張子 `s`）にプログラミング
2. `as` コマンドでアセンブルしてオブジェクトファイル（拡張子 `o`）を生成
3. `ld` コマンドでリンクしてバイナリ（実行可能ファイル）を生成

早速アセンブリを書いていきましょう。上記3ステップでプログラミングから実行までを行うことができます。非常にシンプルですね！

1. 利用するシステムコールの把握
2. システムコールの引数に指定する値をレジスタに格納
3. システムコールの実行
4. プログラムの正常終了

今回、上記4ステップでアセンブリを書いていきます。  
機械語に近いアセンブリであっても、CPU を自由自在に操作できるわけではなく、カーネルに対してシステムコールを行うことで処理を実行することになります。これは Swift で `print` 関数を用いて標準出力を行う感覚に近いかもしれません。

### 1. 利用するシステムコールの把握
システムコールの内容は Apple から `syscalls.master` というファイル（※2）で公開されています。今回は `Hello, World!` の表示を行いたいので、標準入出力が可能な `write` 関数を利用することにします。

```
4	AUE_NULL	ALL	{ user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte); }
```

システムコール一覧には様々なカラムが存在しますが、両端の要素に着目してみましょう。左端はシステムコールナンバーを示しており、アセンブリではこの番号を使うことになります。そして、右端がシステムコールの定義となります。我々はこの定義から使いたいシステムコールナンバーを探すことになります。  

※2: https://opensource.apple.com/source/xnu/xnu-1504.3.12/bsd/kern/syscalls.master

### 2. システムコールの引数に指定する値をレジスタに格納
利用するシステムコールが決まったら、システムコールの定義を元にアセンブリを書いていくことになるのですが、マスターファイルに書かれている内容は最低限の定義のみなので更に詳しく調べる必要があります。

```sh
man write
```

システムコールの詳細は `man` コマンドで調べることができます。  
日頃我々が使っている Swift のようにシステムコールの呼び出し時には引数を渡すことができます。

```c
{
    // - Parameters:
    //   - int: fd 入力は0、出力は1、エラーは2を指定
    //   - user_addr_t: cbuf
    //   - user_size_t: nbyte
    // - Returns:
    //   - user_ssize_t
    user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte);
}
```

先ほど紹介したマスターファイルの定義を元に引数を確認していきましょう。C言語シンタックスで書かれており、3つの引数を取り、1つの戻り値があることが分かります。  
アセンブリでは、引数に渡す値も明示的にレジスタへ格納して上げる必要があります。ですから、システムコールを行う前に上記で確認した3つの値をレジスタへ格納する処理から書いていきます。

```s
mov X0, #1
adr X1, greeting
mov X2, #16

greeting: .ascii "Hello, AkkeyLab\n"
```

3つの引数をレジスタに格納するコードは上記のようになります。  
これは `AArch64 アセンブリ記法` と呼ばれる記法で `ARM アセンブリ記法` の 64bit 版です。左からニーモニックと呼ばれる命令、レジスタ、命令の対象となる値、という順番で書かれています。  
なので、 `mov X0, #1` は `1` を `X0` に `mov` すると読むことができます。 `mov` は値の移動を行う命令なので、レジスタの番地 `X0` に `1` を格納しているのだと分かります。これが `write` システムコールの第一引数に渡したい値で、今回は文字列の「出力」を行いたいので `1` を指定しています。

2行目では `adr` という命令が利用されています。これは Address を意味するもので、シンボルのアドレスをレジスタへ格納するためのものです。ここでは `greeting` というラベルを指定しており、Swift における変数定義のように扱うことができます。つまり、 `greeting: .ascii "Hello, AkkeyLab\n"` で表示したい文字列をラベルを経由して指定していることが分かります。これが `write` システムコールの第二引数に渡したい値となります。

3行目は1行目と同じ `mov` 命令で3つ目の引数である文字列の長さを指定しています。改行コードを1文字としてカウントしている点に注意しましょう。これが `write` システムコールの第三引数に渡したい値となります。

### 3. システムコールの実行
引数に渡す値をレジスタへ指定することができたので、実際にシステムコールを記述していきます。今まではレジスタの番地として `X0~2` を利用してきましたが、システムコールを行う時は特別な番地を使用する必要があります。

```s
mov X16, #4
svc #0x80
```

システムコールを行う時はレジスタ `X16` にシステムコールナンバーを指定します。初めにマスターファイルで確認した `4` を指定することで `write` システムコールを行います。  
`svc` 命令は `Supervisor Call` の略で、システムコールを実行するための特殊な割り込み命令です。これが呼ばれた時、レジスタ `X16` に指定されたシステムコールナンバーに従った処理をカーネルに指示します。

### 4. プログラムの正常終了
アセンブリではプログラムの終了も明示的に記述する必要があります。  
まず、システムコールマスターファイルを見ると以下のようなシステムコールがあることが分かります。

```
1	AUE_EXIT	ALL	{ void exit(int rval); }
```

これは、システムコールナンバーが `1` で終了ステータスを引数に指定する必要があると読み取ることができます。もちろん、詳細は `man exit` で調べることができます。  

```s
mov X0, #0
mov X16, #1
svc #0x80
```

いかがでしょうか。最初は読めなかったアセンブリも読めるようになってきたように感じませんか？今回は正常終了させたいので終了ステータスは `0` です。  
以上で文字列の標準出力を行うプログラムが完成しました。プログラムのエントリーポイント指定などを追加して実際に動作するようにしたコードを以下に示します。

```s
.global _start
.align 2

_start:
    mov X0, #1 
    adr X1, greeting
    mov X2, #16
    mov X16, #4
    svc #0x80
    mov X0, #0
    mov X16, #1
    svc #0x80

greeting: .ascii "Hello, AkkeyLab\n"
```

## 様々な記法
標準出力の方法について学んだところで、本稿のタイトルを思い出してみましょう。これは本当に Apple Silicon 特有のものなのでしょうか。Intel CPU を搭載した旧 MacBook でも実行できてしまえば、軽くタイトル詐欺ということになります。

---

最後までお読みいただきありがとうございます。  
文系・理系関係なく楽しんでいただけるように執筆したと初めに書きましたが、非常に難易度の高い内容に感じた方もいたかもしれません。ですが、今年の iOSDC はオフライン開催が予定されておりますので、ぜひ私を探して質問攻めしちゃってください。  
また、本稿は GitHub で管理されておりますので、気軽に issue などの形で質問や修正依頼いただけますと幸いです。

## 著者
- AkkeyLab株式会社 代表取締役
- 株式会社AppBrew エンジニア
- 合同会社アイネット エンジニア

本稿執筆時点で3社に所属するプログラマー兼経営者。  
緑の毛色が特徴の初代ファービーを両親に買ってもらって遊んだのが良い思い出。遊んでいる間に何をしてもすぐに寝てしまうようになってしまい、乾電池を抜いてしまった。アセンブリを読めば、なぜすぐ寝てしまうのか解読できるのかもしれませんね。
