# AkkeyLab 流イミフクラッシュ解読術

## Introduction
- 手元で再現できない
- 心当たりのないクラッシュ
- 何ヶ月も触ってない行でクラッシュ

このように嫌な予感がする現象に皆さん一度は遭遇したことがあるのではないでしょうか。  
そして、調査手順次第ではもっと早く原因特定できたのに…と悔しい思いをしたこともあるかもしれません。  
そこで、本稿では効率的な原因探索方法を図を用いて解説いたします。ぜひ、本稿を元にチームでアレンジを加え、秘伝のタレとして育ててみてはいかがでしょうか？ドメイン知識の薄い新メンバーも爆速で難問解読のプロになること間違いなしです！

本稿は GitHub で管理されており、最新の状態が閲覧できるだけでなく、皆様からのご指摘にも対応可能となっております。ぜひ、ご活用ください。  
GitHub: https://github.com/AkkeyLab/technical-article

## 前提
本稿ではグラフの描画に mermaid を利用して執筆いたしました。そのため、皆さんの開発環境に合わせた改良が施しやすくなっております。  
ちなみに、私が所属するWED株式会社のエンジニアチームでは mermaid を GitHub や Notion 上で積極的に利用しており、業務でも利用されることが増えているツールのように感じます。ですから、mermaid をまだ使ったことがないという方は本稿も参考に導入を検討してみてはいかがでしょうか。

## 1. 問題の認知
```mermaid
flowchart LR;
    id-cognition(Problem\nRecognition)
    user("User")-->id-cognition
    alert("Alert")-->id-cognition
    debug("Debug")-->id-cognition
    id-cognition-->id-release{"Recent\nReleases"}
    id-release--"App"-->id-fix("Fix App")
    id-release--"None"-->id-expect{"Expect"}-.->next("Some")
    id-release--"Server"-->id-revert("Revert Server")
    id-cognition-->id-fix
    id-cognition-->id-revert
    id-fix-->rereview("App Re-review")
    id-fix-.->workaround("Workaround by Server")
```

これから難問の解読方法をいくつか紹介していくのですが、不具合が発生・発覚した場合の基本的な対処方法の実施が前提になります。ということで、まずは基礎から見ていきましょう。

### 3つのトリガー
我々開発者が問題が発生していることを認知することになるトリガーは大きく3つあります。  
まず、ユーザからのお問い合わせです。IT リテラシーの度合いによっては、不具合だと勘違いしていたり、「クラッシュ」「閉じる」「フリーズ」などの用語を間違って利用していたりするため、サービス側の不具合だと判断することは決して簡単ではありません。最低限、類似のお問い合わせが短期間に複数あった場合は調査を行うというルールを設けておく必要があるでしょう。

次に、アラート通知です。ネイティブアプリでは Firebase Crashlytics が有名です。メール・Slack・電話など緊急度合いに合わせて開発者に通知する仕組みを活用することと、それを受け取ったときの対応方針を事前に決めておくことが重要です。

最後に、開発中に気づくパターンです。たまたまユーザがあまり遭遇しないパターンでの不具合やリリース前の機能に対する不具合を開発中に発見することがあります。どれだけ開発が忙しくてもタスクとして書き出すことを怠ってはいけません。

### 直近の変更を疑う
問題を認知したら優先度を決めて対応を方針を決めていきます。原因が明確な場合は直接修正作業に移行できますが、そうでない場合は順に調査をしていく必要があります。  
まずは、問題が発生し始めたと考えられるタイミング周辺でリリースが行われていたかの確認を行います。アプリで段階リリースなどを行っている場合はそれも考慮した範囲で確認する必要があります。  
次に、そのリリースがサーバで行われていた場合、可能であれば切り戻し作業を実施します。アプリの場合は修正を行って申請（緊急時は特急申請）するという流れになりますが、一定の時間を要するため、サーバ側で応急処置を施すという選択肢もあります。

### 何もしてないのに…
直近リリースを行っておらず、設定の変更なども行っていないという場合の調査方法は様々です。その調査方法についても以後ご紹介いたします。

## 2. アプリ起因の不具合
アプリ側の実装によって発生するようになったクラッシュであるというところまで原因特定が出来ている場合を考えてみましょう。  
スタックトレースの確認と手元で再現するかの確認は必須です。問題はこれで原因特定が出来なかった場合です。

```mermaid
flowchart LR;
    id-alert("Crash Alert")-->id-stack-trace("Show Stack trace")
    id-stack-trace-->local-crash{"Crash\nlocally ?"}--"Yes"-->id-find("Bug find !")-->id-fix(("Fix"))-->id-alert
    local-crash--"No"-->os_device("Check\nOS & Device")-->id-find
    local-crash--"No"-->logs("Check Logs")-->id-find
    local-crash--"No"-->disable-code("Disable code")-->id-fix
    fixed-disable("Fixed by disable code")-->id-find
```

### クラッシュ直前の規則性
スタックトレースとセットで見ていただきたいのがイベントログやスクリーンログです。これらを用いて、クラッシュ直前のログに規則性がないか複数のログから確認を行います。  
この調査方法が有効なシチュエーションとしては、クラッシュ箇所とは別のところに引き金が潜んでいるケースです。例えば、チュートリアル動画再生部分でメモリリークが発生し、その後の操作でクラッシュしてしまうケースが考えられます。この場合、クラッシュしているユーザは直前にチュートリアル動画を視聴しているという規則性が見られるはずです。

### 一度変更を戻してみる
「手元でも再現しない、ログからも原因がはっきりしない、でもココらへんが原因でクラッシュするようになったのは確かなようだ」このように煮詰まってしまうこともあるでしょう。  
このような場合は思い切って原因と思われる箇所を元に戻してリリースしてみましょう。悔しいですが、調査中にも多くのユーザがクラッシュに遭遇し、最悪の場合それが原因で離脱しているという状況は早急に対処しなければなりません。

ポイントはどれだけ元に戻すかです。  
「直近のリリースでプロフィール画面を触っていて、プロフィール画面内でのクラッシュが発生するようになった」のように、ざっくりとした原因箇所が分かる場合はそこのみをもとに戻すという選択肢もあります。これにより、他の変更箇所はクラッシュに関係ないとして調査を進めることができるようになります。  
ただし、クラッシュ遭遇率が高いなど緊急度が高い場合はリリース全体の切り戻しを行うことをおすすめします。これは、先程の「ざっくりとした原因箇所」が間違っていた場合というリスクを排除するためです。

### 再現させるための工夫
ここで、不具合を再現する手助けとなるポイントをいくつかご紹介します。ただし、ログ経由で分かる端末の種類や端末の向き、OS バージョンなどは除外しています。

- 通信
  - 通信キャリア
  - Wi-Fi
    - インターネット・サービス・プロバイダーでの制限
- 低スペック環境での確認
  - 通信速度
  - サポートしている中で最も古い端末
  - バッテリー容量が低下した場合の処理速度低下
- 本体設定
  - ダークモード・ライトモード
  - 言語と地域の組み合わせ
- どのようにアプリを開くか
  - プッシュ通知
  - ウィジェット
  - URL scheme
  - バックグラウンド

## 3. 外部要因の不具合
外部要因によって通信エラーやクラッシュが発生しているというところまで原因特定が出来ている場合を考えてみましょう。  
通信エラーだと CDN が原因の大規模障害、クラッシュだと特定のバージョンの FacebookSDK を組み込んだアプリが起動不能になる大規模障害などが実際に発生しています。

```mermaid
flowchart LR;
    id-alert("Crash Alert")-->id-stack-trace("Show Stack trace")-->id-third-party{"Third party\nLibrary ?"}
    id-third-party-."No".->id-some("Some")-->id-fix(("Fix"))
    id-third-party--"Yes"-->id-api-status("Check\nAPI status")
    id-third-party--"Yes"-->id-twitter("Show Twitter")-.->id-fix
    id-twitter-->id-notification(("Notification"))
    id-api-status-->id-notification
    id-api-status-->id-fix
    server-alert("Server Alert")-->console("Show console")-->id-third-party
```

### ステータス確認
クラッシュや通信エラーのログからサービス内で利用しているサードパーティ製ツールが原因と考えられる場合、ステータス確認を行いましょう。ここで原因特定ができ、外部サービスの復旧を待たなければならない場合は、その旨をユーザに通知しましょう。

### Twitter を確認
上記で「ステータスを確認しましょう」と書きましたが、実際少しラグがあります。あなたがバックエンドも担当しているのなら、他のエンジニアが同じ状態に遭遇していないか、原因はどこにありそうなのかなどを事前に仕入れて調査を開始することが非常に重要になってきます。  
そんな時に活用できるのが Twitter です。皆さんは、GitHub ページにユニコーンが現れたとき（障害発生時に）Twitter を見に行きませんか？それと同じです。

しかし、注意しなければならないこともあります。非公式の情報を真に受けてはいけないことは誰もが意識していると思いますが、他人に伝達する時に非公式情報であることもセットで伝えるように気をつける必要があります。

GitHub Unicorn: https://github.com/503.html

---

最後までお読みいただきありがとうございます。

このように問題発生時の調査・対応手順をドキュメント化しておくことは非常に重要です。  
詳しいメンバーが有給休暇中・体調不良、深夜など予期しないタイミングで発生することが多いのが障害です。こんな時、メンバーが対応手順を把握しているかで対処スピードは大きく変わることでしょう。  
また、 mermaid を使えばドキュメントのメンテナンスコストも低くすることができるかもしれません。

どこか一箇所でも皆さんの環境に活かせるものがあると嬉しいです。  
本稿は GitHub で管理されておりますので、気軽に issue などの形で質問や修正依頼いただけますと幸いです。
